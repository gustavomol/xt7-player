' Gambas class file

Public Fetching As Boolean = False
Public HitCancel As Boolean = False

Public JustFileCover As Boolean = False
Public MediaFileFullPath As String

Public Sub TextBox1_Click()
  Dim PreRequest As String = ""
  Dim Keyword As String
  Dim MYURL As String
  Dim buffer, Tempfile, myline, ImageUrl, Iwidth, IHeigth As String
  Dim Splitted, ImagesURL As New String[]
  Dim Myimage As New Image
  Dim i As Integer = 0

  Progressbar1.value = 0
  'Progressbar1.visible = TRUE
  Progressbar1.h = 24

  HitCancel = False
  Fetching = True
  textbox1.enabled = False
  Me.mouse = Mouse.wait
  ButtonLoad.enabled = False
  Coverlist.Clear
  Coverlist.refresh
  
  Wait 0.01
  'Since August, 15, 2009, amazon requires signed requests.
  'I did request signing via an external php page

  Keyword = Chr(34) & Replace(TextBox1.text, " ", "%20") & Chr(34)
  Keyword = Replace(keyword, ",", "%20")
  Keyword = Replace(keyword, ";", "%20")
  Keyword = Replace(keyword, "-", "%20")
  PreRequest = "http://xt7-player.sourceforge.net/xt7forum/hmac.php?keywords=" & Keyword
  Print PreRequest
  HttpClient1.url = PreRequest
  HttpClient1.Async = False
  HttpClient1.timeout = 10
  HttpClient1.get
  If HttpClient1.status < 0 Then
    Debug "Error: Covermanager: Button1_Click() HTTP ERROR Doing Prerequest to signing proxy"
    Return
  Endif
  If Lof(HttpClient1) Then Read #HttpClient1, buffer, Lof(HttpClient1)
  'Print buffer

'   'MyURL = "http://webservices.amazon.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId=045ZGZ60B4A7NQEJRMR2&Operation=ItemSearch&SearchIndex=Music&Keywords=" & Keyword & "&ItemPage=1&ResponseGroup=ItemAttributes,Small,Images"
  MyURL = buffer
  HttpClient1.url = MYURL
  HttpClient1.Async = False
  HttpClient1.timeout = 60
  HttpClient1.get
  If HttpClient1.status < 0 Then
    Debug "Covermanager: HTTP ERROR while contacting Amazon"
    Return
  Endif
  
  If Lof(HttpClient1) Then Read #HttpClient1, buffer, Lof(HttpClient1)
  Splitted = Split(buffer, "<", "", True)
  Debug "CoverManaer: Button1_Click(): Check dupes"
  For Each myline In Splitted
    If (myline Like "*http://*") And (myline Like "*.jpg") Then
      ImageUrl = Split(myline, ">")[1]
      If ImagesURL.Find(ImageUrl) < 0 Then ImagesURL.Add(ImageUrl)
    Endif
    Wait 0.001
  Next 'myline
  Try Shell "rm -R " & global.confpath & "/covertmp/* >/dev/null 2>&1" Wait
  Try Shell "mkdir -p " & global.confpath & "/covertmp/ >/dev/null 2>&1" Wait
  'PRINT buffer
  Debug "CoverManaer: Button1_Click(): Start downloading covers Now"
  For Each ImageUrl In ImagesURL
    If (Imageurl Like "http://*") And (Not HitCancel) Then
      HttpClient1.url = ImageUrl
      HttpClient1.get
      Wait 0.01
      If HttpClient1.status >= 0 Then
        tempfile = global.confpath & "/covertmp/temp" & Rnd(0, 999999) & ".jpg"
        If Lof(HttpClient1) Then Read #HttpClient1, buffer, Lof(HttpClient1)
        File.Save(tempfile, buffer)
        MyImage = image.Load(tempfile)
        IWidth = Myimage.W
        IHeigth = MyImage.h
        MyImage = MyImage.Stretch(32, 32)
        Try Coverlist.Add(tempfile, IWidth & "x" & IHeigth, MyImage.Picture)
      Endif
      Wait 0.01
      i = i + 1
      Progressbar1.value = i / ImagesURL.count
    Endif
  Next 'ImageUrl
  If HitCancel Then Me.close
  'Progressbar1.visible = FALSE
  textbox1.enabled = True
  Me.mouse = Mouse.default
  If ImagesURL.count = 0 Then Message.Error(("No covers found for:") & "\n" & TextBox1.text & "\n" & ("Try to use less strict terms, remove symbols and so on..."), ("Ok"))
  ButtonLoad.enabled = True
  Fetching = False
End

Public Sub CoverList_Select()
  Dim blackpicture As New Picture
  Picturebox1.picture = Picture.Load(Coverlist.Current.key)
  Picturebox1.refresh
End

Public Sub TextBox1_Activate()
 textbox1_click()
End

Public Sub Form_Open()
  'ME.center
  Global.Center(Fmain, Me)
End

Public CoverCacheList As New ListView(zzzfake)

Public Sub RemoveCoverCache(coverfile As String)
  Dim cachefile As String = coverfile & "_thumbcache" 'ricava il nome dei file cache
  Dim catcherror As Boolean
  Shell "rm '" & cachefile & "'" & "*.*" 'rimuovilo dal disco
  'cercalo in memoria e rimuovilo:
  CoverCacheList.Movefirst
  Repeat
    If CoverCacheList.Item.key Like cachefile & "*" Then
      Debug "invalidating memory cache: " & CoverCacheList.Item.key
      CoverCacheList.Item.delete
      Try CoverCacheList.MoveFirst ' ci si muove all'inizio, perchè dopo la cancellazione
                                    ' l'item corrente non è più valido, quindi non ha un successivo
      If Error Then Return
    Endif
  Until CoverCacheList.MoveBelow()
  FMain.RefreshVisibleCovers(FMain.librarygrid)
  FMain.RefreshVisibleCovers(FMain.playlistgrid)
End


Public Function coverpicture(coverfile As String, uripath As String, width As Integer, Optional ByRef found As Boolean) As Picture
Dim cachefile As String = coverfile & "_thumbcache" & width & "." & File.ext(coverfile)
Dim tmpimage As Image
Dim FileExists As Boolean = False
'gestisce le thumbnails su disco e la loro cache in memoria
'non crea di per sè alcuna immagine, al più restituisce delle immagini di default
'la creazione di eventuali nuove cover va fatta all'esterno
If FMain.closing Then Return
found = True

'IF 1 = 2 THEN

If (global.isvideofile(uripath) And (generaloptions.ShowThumbsChk.value = False)) Then 
  Return Stock[CStr(width + shadowoffset) & "/video"] 
Endif



If Exist(coverfile) Then
  'DEBUG "coverfile exists"
  Try Return Shadowed(CoverCacheList[cachefile].Picture) 'Se esiste l 'immagine in memoria dai l 'immagine in memoria ed esci
  If Error Then 'Se non esiste l 'immagine in memoria, allora
    If Exist(cachefile) Then  'Se esiste una cache su disco allora
      CoverCacheList.Add(cachefile, "", picture.Load(cachefile)) 'mettila IN memoria
      Return CoverCacheList[cachefile].Picture 'ritornala
        Else 'Altrimenti(non esiste cache su disco)
      If Exist(coverfile) 'se esiste la cover su disco, ma non la cache
        tmpimage = image.Load(coverfile).Stretch(width, width) 'caricala
        tmpimage.Save(cachefile) 'salvala come cache
        CoverCacheList.Add(cachefile, "", tmpimage.picture) 'mettila IN memoria
        Return Shadowed(CoverCacheList[cachefile].Picture) 'ritornala
      Endif
    Endif
  Endif
     Else ' IF NOT Exist(coverfile) THEN 'se la cover non esiste, ricava un nuovo coverfile:
  If global.IsNetworkURI(uripath) Then
    coverfile = "webradio.png"
      Else If global.IsVideoFile(uripath) Then
        coverfile = "videocover.png"
      Else 'non è una uri di rete, non è una radio e non c'è alcuna copertina già salvata:
        found = False
        coverfile = "emptycover.png"
  Endif
  cachefile = coverfile & "_thumbcache" & width & "." & File.ext(coverfile)
  If coverfile <> "webradio.png" Then 
    Try Return Shadowed(CoverCacheList[cachefile].Picture) 'prova a restituire l'immagine dalla memoria
      Else
    Try Return (CoverCacheList[cachefile].Picture) 'prova a restituire l'immagine dalla memoria
  Endif
  If Error Then 'se non la trovi in memoria,
    'DEBUG "not found in memory!"
    tmpimage = image.Load(coverfile).stretch(width + shadowoffset, width + shadowoffset) 'caricala
  Endif
  Try CoverCacheList.Add(cachefile, "", tmpimage.Picture) 'mettila IN memoria
  If Error Then Return Null
  Return CoverCacheList[cachefile].Picture 'e restituiscila
Endif
End

Public Function newcoverpicture(coverfile As String, uripath As String, width As Integer) As Picture
  Return LookForJpg(uripath)
End

Public Sub MakeCoverDirs()
   Try Shell "mkdir -p " & global.confpath & "/covers/ >/dev/null 2>&1" Wait
End

Private Uncovered As New String[]
Private UncoveredInitialized As Boolean = False
Private uncoveredfile As String = (global.confpath & "/covers/uncovered.txt") 

Public Sub flushUncoveredFile()
  Dim tmp, myitem As String
  For Each myitem In Uncovered
    tmp &= myitem & "\n"
  Next
  file.Save(uncoveredfile, tmp)
End


Private Sub UncoveredInit()
  Try uncovered = Split(file.Load(uncoveredfile), "\n", "", True)
  UncoveredInitialized = True
End


Public Function IsUncovered(fullpath As String) As Boolean
  If Not UncoveredInitialized Then UncoveredInit()
  Return Uncovered.Exist(file.Name(fullpath))
End

Public Sub MarkUncovered(fullpath As String)
  Dim newfilename As String
  Dim tmppic As Picture
  If (Uncovered.Find(fullpath) = -1) Then Uncovered.Add(file.Name(fullpath))
End

Public Sub UnMarkUncovered(fullpath As String)
  Dim i As Integer
  If Not UncoveredInitialized Then UncoveredInit()
  Try i = uncovered.Find(file.Name(fullpath))
  If Not Error Then uncovered.Remove(i, 1)
End



'thanks to forth for this snippet:
'http://whiteislandsoftware.com/forum/index.php?page=topicview&id=applications-and-code%2Fbase64-encode-decode
Private Const B64Const As String = "=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
Public Sub FromB64(B64Str As String) As String
  Dim Position As Long
  Dim dt As Byte
  Dim B64Decoded, u, c As String
  Dim Tkn, p As Integer
  '
  Position = 1
  Tkn = 0
  Do Until Position > Len(B64Str)
    Wait
    c = Mid(B64Str, Position, 1)
    p = InStr(B64Const, c)
    If p > 1 Then
      p = p - 2
      Inc Tkn
      Select Case Tkn
        Case 1
          dt = (p * &h4)
        Case 2
          B64Decoded = B64Decoded & Chr(dt + ((p And &H30&) / &H10&))
          dt = (p And &HF&) * &H10&
        Case 3
          B64Decoded = B64Decoded & Chr(dt + ((p And &H3C&) / 4))
          dt = (p And &H3&) * &H40&
        Case 4
          B64Decoded = B64Decoded & Chr(dt + p)
      End Select
      If Tkn = 4 Then Tkn = 0
  Else    ' Ej skrivbart tecken
    If p = 1 Then
      Position = Len(B64Str) + 1
    End If
  Endif
  Inc Position
  Loop
  Select Case Tkn
    Case 1
      B64Decoded = B64Decoded & Chr(dt)
  End Select
  Return B64Decoded
End

Public Sub LookForJpgB64(filename As String, Optional saveto As String = "", Optional ByRef fileerror As Boolean = False) As Boolean
  Dim mystream As File
  Dim myjpg As String
  Dim m1 As String = "METADATA_BLOCK_PICTURE=" ' or "COVERART="
  Dim jpgstart, jpgend As Long
  Dim isvalid As Boolean = False
  Dim tmpfile As String = Temp & ".jpg"
  Dim tmppic As Picture
  Dim m1pos As Long
  Dim jpgendmarker1 As String = Chr(01) & Chr(05)
  Dim jpgendmarker2 As String = "00"

  If IsUncovered(filename) Then Return False

  myjpg = ""
  Try mystream = Open filename For Input
  If Error Then 
    fileerror = True
    'Return Null
    Return False
  Endif

  'Return False on Error Or If no pattern could be found
  m1 = "METADATA_BLOCK_PICTURE"
  Try m1pos = FindAndSeek(mystream, 1024, m1)
  If Error Then Return False
  If m1pos = 0 Then 
      Seek #mystream, 0
      m1 = "COVERART="
      Try m1pos = FindAndSeek(mystream, 1024, m1)
      If Error Then Return False
      If m1pos = 0 Then Return False
  Endif

  
  Wait
  jpgstart = m1pos + Len(m1)

  'se il file jpg non è valido, reitera questo finchè non è valido
  While Not isvalid
    Repeat
      Try jpgend = FindAndSeek2(mystream, 4096, jpgendmarker1, jpgendmarker2)
      If Error Then Return
      Wait
    Until jpgend > 0
    Debug "Found a potential jpeg of " & (jpgend - jpgstart - 1) & " bytes for " & filename
    Wait
    If (jpgend - jpgstart) > 307200 '307200 Then
      Debug "jpg is >300KB, probably corrupted, skipping"
      Return False
    Endif

    Seek #mystream, jpgstart
    myjpg = Read #mystream, (jpgend - jpgstart - 1) 
    myjpg = FromB64(myjpg)
    'make sure myjpg starts with "FF D8"
    jpgstart = InStr(myjpg, Chr(255) & Chr(216))
    myjpg = Mid(myjpg, jpgstart, Len(myjpg) - jpgstart)
    'If Error Then Return False
    file.Save(tmpfile, myjpg)
    Try tmppic = picture.Load(tmpfile)
    If Not Error Then 
      isvalid = True
      Seek #mystream, jpgstart
    Endif
    Wait
  Wend
  If isvalid 
    If saveto <> "" Then Try Copy tmpfile To saveto
    Return True
      Else
    Return False
  Endif
End

Public Function FindAndSeek(mystream As File, myblock As Long, mypattern As String) As Long
  Dim chunk As String
  Dim mypos As Long
  Dim mystart As Long = Seek(mystream)
  Chunk = Read #mystream, myblock
  mypos = InStr(chunk, mypattern)
  If mypos > 0 Then 
    Seek #mystream, mypos
    Return mystart + mypos
      Else
    Return 0
  Endif
End

Public Function FindAndSeek2(mystream As File, myblock As Long, mypattern1 As String, mypattern2 As String) As Long
  Dim chunk As String
  Dim mypos As Long
  Dim mystart As Long = Seek(mystream)
  Chunk = Read #mystream, myblock
  mypos = InStr(chunk, mypattern1)
  If mypos = 0 Then mypos = InStr(chunk, mypattern2)
  If mypos > 0 Then 
    Seek #mystream, mypos
    Return mystart + mypos
      Else
    Return 0
  Endif
End

Public Sub LookForJpg(filename As String, Optional saveto As String = "", Optional ByRef fileerror As Boolean = False) As Boolean
   Dim mystream As File
   Dim myjpg As String = ""
   Dim m1 As String = "image/"
   Dim isvalid As Boolean = False
   Dim tmpfile As String = Temp & ".jpg"
   Dim tmppic As Picture
   Dim chunk As String
   Dim m1pos As Long
   Dim jpgstartmarker As String = Chr(255) & Chr(216)
   Dim jpgendmarker As String = Chr(255) & Chr(217)
   Dim jpgstart, jpgend As Long
   
  If IsUncovered(filename) Then Return False

  Try mystream = Open filename For Input
  If Error Then 
    fileerror = True
    Return False
  Endif
  Wait
  Try m1pos = FindAndSeek(mystream, 1024, m1)
  If Error Then Return False
  If m1pos = 0 Then Return False
  Wait
  Try jpgstart = FindAndSeek(mystream, 2048, jpgstartmarker)
  If Error Then Return False
  If jpgstart = 0 Then Return False
  jpgstart = jpgstart - 1
  Wait
   'se il file jpg non è valido, reitera questo finchè non è valido
  While Not isvalid
    Repeat
      Try Chunk = Read #mystream, 4096 'look for jpeg end marker in the next 4K
      If Error Then Return False 'eof...
      jpgend = InStr(chunk, jpgendmarker)
      Wait
    Until jpgend > 0
    jpgend = Seek(mystream) - 4096 + jpgend + 1

    If jpgend > 0 Then
      'Debug "Found a potential jpeg of " & (jpgend - jpgstart) & " bytes for " & filename
      If (jpgend - jpgstart) > 307200 '307200 Then
        Debug "jpg is >300KB, probably corrupted, skipping"
        'Return Null
        Return False
      Endif
    Endif
    Wait
    Seek #mystream, jpgstart

    myjpg = Read #mystream, (jpgend - jpgstart) 
    file.Save(tmpfile, myjpg)
    Try tmppic = picture.Load(tmpfile)
    If Not Error Then 
      isvalid = True
      Seek #mystream, jpgstart
        Else
      Seek #mystream, jpgend
    Endif
    If Eof(mystream) Then
      Return False
    Endif
    Wait
  Wend

  Close mystream
  If isvalid 
    If saveto <> "" Then Try Copy tmpfile To saveto
    Return True
      Else
    Return False
  Endif
End



Public Sub PictureBox1_DblClick()
  Dim newfilename As String
  Dim currentfilename As String
  CoverManager.close
  'stop any previous search
  HitCancel = True
  'set new cover
  newfilename = Coverfile(ArtistText.text, AlbumText.text)
  
  Try currentfilename = Coverlist.Current.key
  If Not Error Then
    Try Kill newfilename
    Try Copy currentfilename To ((newfilename))
  Endif
  Try RemoveCoverCache(newfilename)
  FMain.CoverRefresh()

  Wait 0.05
  Try currentfilename = Coverlist.Current.key
  If Not Error Then
    Try Kill newfilename
    Try Copy currentfilename To ((newfilename))
  Endif
  Try RemoveCoverCache(newfilename)
  FMain.CoverRefresh(True)
End


Public Sub CoverList_DblClick()
  PictureBox1_DblClick()
End

Public Sub ButtonAccept_Click()
  PictureBox1_DblClick()
End

Public Sub ButtonCancel_Click()
  HitCancel = True
  Me.close
End

Public Sub ButtonUnset_Click()
  Dim newfilename As String
  newfilename = (Coverfile(ArtistText.text, AlbumText.text))
  'newfilename = SConv(global.confpath& "/covers/" & global.fixfilename(Upper(ArtistText.text)) & "^^^" & global.fixfilename(Upper(AlbumText.text) & ".jpg"))
  Try Kill newfilename
  Try RemoveCoverCache(newfilename)
  Picturebox1.picture = Picture.Load("emptycover.png")
  Picturebox1.refresh
  FMain.CoverRefresh()
End

Public Function Coverfile(artist As String, album As String, Optional fullpath As String = "") As String
  'return the cover file basing on album and artist information OR filename
  If fullpath = "" Then fullpath = MediaFileFullPath
  If (Trim(artist) = "" And Trim(album) = "") Then 'use filename instead
    Return global.confpath & "/covers/" & global.fixfilename(fullpath) & ".jpg"
      Else
    Return global.confpath & "/covers/" & global.fixfilename(Upper(Trim(Artist))) & "^^^" & global.fixfilename(Upper(Trim(Album)) & ".jpg")
  Endif
End





Public Sub ButtonLoad_Click()
  Dim PrevTitle As String
  Dim PrevFilter As String[]
  Dim newfilename As String
  Dim currentfilename As String
  Coverlist.clear
  With Global
    Dialog.Path = .StartFolder
    PrevFilter = Dialog.filter
    Prevtitle = Dialog.title
    Dialog.Title = ("Load a Jpg cover image")
    Dialog.filter = ["*.jpg", "jpg files"]
  End With
  If Dialog.OpenFile() Then Return
  Dialog.filter = PrevFilter
  Dialog.title = PrevTitle
  
  Try Shell "mkdir -p " & global.confpath & "/covers/ >/dev/null 2>&1" Wait
  'newfilename = SConv(global.confpath& "/covers/" & Upper(ArtistText.text) & "^^^" & Upper(AlbumText.text) & ".jpg")
  newfilename = (Coverfile(ArtistText.text, AlbumText.text))
  currentfilename = (Dialog.Path)
  Try Kill newfilename
  Try Copy currentfilename To newfilename
  'TRY SHELL "cp " & currentfilename & " " & global.fixfilename(newfilename) & " >/dev/null" WAIT
  Try Picturebox1.picture = Picture.Load(newfilename)
  If Error Then
    Message.Error(("Error while loading the picture"), "Ok")
  Endif
  Picturebox1.refresh
  FMain.CoverRefresh()
  Try RemoveCoverCache(newfilename)
End

Public Sub Form_KeyPress()
  If Key.code = Key.escape Then ButtonCancel_Click()
End

Public Sub Form_Close()
  ButtonCancel_Click()
End

Public Sub SetACover(fullpath As String, artist As String, album As String, Optional forcesearch As Boolean = False)
  
  Dim timeout As Integer = 15 ' how much to wait for the other fetch to finish
  Dim tmpmessage As String
  Dim JustFileCover As Boolean = False 'are we going to set a cover for just this file?
  Dim tl As New TagLib
  
  If CoverManager.fetching Then
    CoverManager.HitCancel = True
    Repeat
      Wait 0.1
      timeout = timeout - 1
    Until (CoverManager.fetching = False) Or (timeout = 0)
  Endif
  
  If Upper(FullPath) Like "*.FLAC" Then
    If (Trim(Artist) = "") And (Trim(Album) = "") Then
      tl.init(FullPath)
      Artist = tl.Artist
      Album = tl.Album
      tl.tlFree()
    Endif
  Endif
  
  If (Trim(Artist) = "") And (Trim(Album) = "") Then
    JustFileCover = True
    tmpmessage = ("\nso you are going to set a cover for this particular file/stream")
    Message.Info(("Artist Or Album tag information are required to set a cover") & tmpmessage, ("Ok"))
  Endif
  progressbar1.value = 0
  If fetching Then
    Message.Info(("Another cover search is in progress, please wait for it to finish!"), "Ok")
    Return
  Endif

    If global.IsAudioFile(fullpath) Then
      If (ArtistText.text & AlbumText.text) <> Trim(Artist) & Trim(Album) Then
        Try CoverList.Clear
        'Try FlexSpace.Picture = picture.Load("null.png")
        Try CoverList.Refresh
        'Try FlexSpace.refresh
        ArtistText.text = Trim(Artist)
        AlbumText.text = Trim(Album)
        TextBox1.text = ArtistText.text & " " & AlbumText.text
        'picturebox1.picture = AudioForm.CoverBox.Picture
        Try Picturebox1.picture = picture.Load(coverfile(artist, album, fullpath))
        picturebox1.refresh
        Me.show
        Wait 0.1
        If ((Not Exist(Coverfile(ArtistText.text, AlbumText.text))) And Not JustFileCover) Or forcesearch Then
          textbox1_Click() 'start a fetch
        Endif
      Endif
      JustFileCover = JustFileCover
      MediaFileFullPath = FullPath
      Me.show
    Endif
End


Private CoversLookerTimer As New Timer As "CoversLookerTimer"

Private QueuedCover As Collection
Private CoverQueue As New Variant[]

Public Sub CoversLookerTimer_timer()
 Dim WorkingCover As New Collection
 Dim artist, album, fullpath As String
 Dim row, firstR, lastR As Integer
 Dim mygrid As Gridview
 Dim mypicture As Picture
 Dim fullpathcheck As String
 Dim fullpathindex As Integer = 19 'fixme, il fullpathindex andrebbe calcolato da playlist.columnindex["full path"]
 Dim savedtext As String
 Dim savedback As Integer
 Dim rowheight As Integer = 24 - global.rowpadding

 If CoverQueue.count = 0 Then
   CoversLookerTimer.Stop
   Return
 Endif
 If FMain.closing Then Return
 WorkingCover = CoverQueue.Pop()
 fullpath = CoverQueue.Pop()
 mygrid = WorkingCover["mygrid"]
 artist = WorkingCover["artist"]
 album = WorkingCover["album"]
 row = WorkingCover["row"]



'If the file isn't found, then mark it into the array
'and discard the cell; next data event will paint an error icon on it.
'we do this onto this timer event to make that async and don't block scrolling.
 If filesnotfound.Find(fullpath) <> -1 Then
   'mygrid[row, 0].picture = picture["icon:/" & (rowheight -global.rowpadding) & "/error"]
   mygrid[row, 0].clear
   Return
     Else 'file not (yet?) marked as not found
   If Not global.IsNetworkURI(fullpath) Then
     If Not Exist(fullpath) Then
       Debug "Missing file! " & fullpath
       FileNotFoundAdd(fullpath)
        'mygrid[row, 0].picture = picture["icon:/" & (rowheight -global.rowpadding) & "/error"]
        mygrid[row, 0].clear
       Return
     Endif
   Endif
 Endif



'controlla se la row è visibile:
 If MyGrid.Rows.count <= 0 Then Return
 FirstR = MyGrid.RowAt(MyGrid.y)
 LastR = MyGrid.RowAt(MyGrid.h)

 If LastR = -1 Then LastR = Mygrid.rows.count - 1
 If firstR = -1 Then firstR = 0
 If Not ((row >= firstR) And (row <= lastR)) Then Return


'se lo è, controlla che ad essa corssiponda lo stesso file
 If mygrid[row, 19].text <> fullpath Then Return


 'controlla di nuovo che alla row corrisponda lo stesso file
 If mygrid[row, 19].text <> fullpath Then Return
 'inserisci immagine

 savepic(fullpath, artist, album, generaloptions.IconsizeCombobox.text, True)
 Try mygrid[row, 0].clear

End

Public Sub QueueThumb(MyGrid As Gridview, fullpath As String, artist As String, album As String, row As Integer, Optional rowheight As Integer = 16)
  QueuedCover = New Collection
  
  If global.IsVideoFile(fullpath) Then
    If Not (generaloptions.ShowThumbsCHK.value) Then
      mygrid.data.Picture = Stock[rowheight + ShadowOffset & "/video"]
      Return  
    Endif
    
  Endif
  
  
  mygrid.data.Picture = Stock[rowheight & "/clock"]
  QueuedCover["mygrid"] = MyGrid
  QueuedCover["artist"] = artist
  QueuedCover["album"] = album
  QueuedCover["row"] = row
  CoverQueue.Push(fullpath)
  CoverQueue.Push(QueuedCover)
  CoversLookerTimer.delay = 1
  CoversLookerTimer.start
End

Public filesnotfound As New String[]
Public Sub FileNotFoundAdd(path As String)
  If (filesnotfound.Find(path) = -1) Then filesnotfound.Add(path)
End


Public Function SavePic(fullpath As String, artist As String, album As String, rowheight As Integer, Optional forcethumbs As Boolean = False)
  Dim coverfilename As String
  coverfilename = coverfile(artist, album, fullpath)
  'controlla se esiste il coverfile su disco
  'se non esiste, prova a crearlo dalle immagini embedded
  If (Not Exist(coverfilename, True)) Then EmbeddedToCoverCache(artist, album, fullpath, coverfilename)
  If Not global.isvideofile(fullpath) Then
    If (Not Exist(coverfilename, True)) Then MarkUncovered(fullpath)
  Endif
End



Public Sub EmbeddedToCoverCache(artist As String, album As String, fullpath As String, coverfilename As String)
  Select Case Lower(file.Ext(fullpath))
    Case "mp3"
      LookForJpg(fullpath, coverfilename)
      Return
    Case "ogg"
      LookForJpgb64(fullpath, coverfilename)
      Return
    Case "flac"
      LookForJpg(fullpath, coverfilename)
      Return
  End Select
  
  If global.IsVideoFile(fullpath) Then
    If generaloptions.ShowThumbsCHK.value Then makevideothumb(fullpath, coverfilename)
  Endif
End


Public ThumbsToBeMade As New String[]
Private thumbstimer As New Timer As "thumbstimer"
Private runningthumblers As Integer = 0
Private mplayerthumb As Mplayerclass

Public Sub makevideothumb(fullpath As String, coverfilepath As String)
  While runningthumblers >= 3
    'Debug runningthumblers
    Wait 0.05
  Wend
  If FMain.closing Then Return
  If Exist(coverfilepath) Then Return
  mplayerthumb = New Mplayerclass As "thumbnailer"
  runningthumblers += 1
  mplayerthumb.savethumb(fullpath, coverfilepath)
End

Public Sub thumbnailer_ThumbAvailableFor(fullpath As String)
  FMain.NewThumbReadyFor(fullpath)
  runningthumblers -= 1
End

Public Sub thumbnailer_ThumbErrorFor(fullpath As String)
  MarkUncovered(fullpath)
  runningthumblers -= 1
End


Public Function DefaultLibraryIcon(fullpath As String, Optional rowheight As Integer = 16) As Picture
  rowheight += Shadowoffset
  If Global.IsAudioFile(fullpath) Then
    Return Stock[rowheight & "/audio"]
  Else If Global.IsVideoFile(fullpath) Then
    Return Stock[rowheight & "/video"]
  Else If Global.IsDvbURI(fullpath) Then
    Return picture["filetypedvb.png"].Resize(rowheight, rowheight)
  Else If FMain.Youtube.IsYoutubeLink(fullpath) Then
    Return picture["youtubeicon.png"].Resize(rowheight, rowheight)
  Else If Global.IsNetworkURI(fullpath) Then
    Return Stock[rowheight & "/network"]
  Else
    Return Stock[rowheight & "/file"]
  Endif
  
End



Private shadowpic As Picture = picture["shadow.png"]
Public ShadowOffset As Integer
Private ShadowOffsetPaint As Integer

Public Sub ResizeShadowTemplate(w As Integer)
  shadowpic = picture["shadow.png"]
  ShadowOffset = (CInt(generaloptions.IconsizeCombobox.text) Div 8) 
  ShadowOffsetPaint = (ShadowOffset Div 2)
  shadowpic = shadowpic.Image.Stretch(CInt(w) + ShadowOffset, CInt(w) + ShadowOffset).picture
  Debug
End

Public Function Shadowed(src As Picture) As Picture
  Dim offset As Integer = 0
  Dim w As Integer = src.w
  offset = - (w Div 90) 
  Return shadowpic.Image.DrawImage(src.image, shadowoffsetpaint + offset, shadowoffsetpaint + offset).picture
End


